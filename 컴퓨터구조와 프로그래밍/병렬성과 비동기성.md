# 병렬성과 비동기성(컴퓨터는 어떻게 한 번에 많은 일을 하는가)

- **경합조건** : 잔고가 100만원인 계좌에서 동시에 75만원과 50만원을 인출하려는 경우
  - 은행에서는 계좌를 잠가서 둘 중 한개의 거래만 처리
  - 일부 연산에 대해서는 근본적으로 멀티태스킹을 막아야 함을 의미

## 경합조건?

- 경합 조건은 2개 이상의 프로그램이 같은 자원에 동시에 접근하고, 자원 사용 순서에 따라 결과가 달라지는 경우를 뜻함

| 프로그렘 1             | 프로그렘 2             | 잔고     | 프로그렘1              | 프로그렘2              | 잔고     |
| ---------------------- | ---------------------- | -------- | ---------------------- | ---------------------- | -------- |
|                        |                        | 100만 원 |                        |                        | 100만 원 |
| 100만 원 읽음          |                        | 100만 원 | 100만 원 읽음          |                        | 100만 원 |
| 읽은 값에 10만 원 더함 |                        | 100만 원 | 읽은 값에 10만 원 더함 |                        | 100만 원 |
| 110만 원 write         |                        | 110만 원 |                        | 100만 원 읽음          | 100만 원 |
|                        | 110만 원 읽음          | 110만 원 |                        | 읽은 값에 50만 원 더함 | 100만 원 |
|                        | 읽은 값에 50만 원 더함 | 110만 원 | 110만원 write          |                        | 110만 원 |
|                        | 160만 원 write         | 160만 원 |                        | 150만 원 write         | 150만 원 |

- 공유 자원(계좌)에 접근하는 타이밍에 따라 달라짐

## 프로세스와 스레드

- 운영체제는 **프로세스**를 관리
  - 프로세스는 **사용자 공간**에서 독립적으로 실행되는 프로그렘

- 멀티코어 시스템에서는 여러 프로그렘이 병렬로 실행될 수 있음

- 프로세스가 자원을 공유하려면 미리 준비를 해야함

  - 자원을 공유하는 프로세스 사이에 통신을 해야 한다는 뜻

  

- **스레드**: 정적인 데이터와 힙을 **공유**하지만, 자체적으로 스택을 갖는 프로그램의 일부분

- 각 스레드는 자신이 CPU 레지스터를 완전하 소유한다고 가정

  - 따라서 한 스레드에서 다른 스레드로 실행이 넘어갈 때는 스레드 스케줄러가 CPU 레지스터를 저장해야함
  - 스레드는 일반 프로세스보다 저장할 컨텍스트 크기가 훨씬 작기 때문에 프로세스 문맥 전환보다 스레드 문맥 전환이 빠름
  - 경량 프로세스 라고 부르기도 함

- 스레드의 문제점

  - 데이터를 공유하기에 보안 문제 발생
  - 한 탭에서 문제가 생기거나 버그가 발생시 전체 프로세스가 멈춰버림
  - 어떤 스레드가 작업완료에 너무 많은 시간이 걸리면 다른 스레드가 실행되지 못해서 문제 발생



## 락

- 위 경합조건을 해결하기 위해서는 여러 작은 연산으로 이루어진 작업을 원자적으로 만들어야 함
  - 프로그렘1이 작동되는 동안 프로그렘 2가 작동되지 않게 계좌 잠금이 필요
  - 그렇다면 프로그렘1의 통신이 느리거나 악의적으로 동작할 경우 프로그렘2는 뭘 해야 할까?

### 트랜잭션과 작업 크기

-  프로그램1의 연산은 은행과 통신할 필요가 있음
  - 다음 연산을 수행하기 전에 앞의 연산이 성공했는지 알아야 해서 양방향 통신
- 성능을 향상할 가장 좋은 방법은 여러 연산을 한 **트랜잭션**에 넣는 것
  - 이 경우 모든 연산은 다 성공하거나 모두 실패함
- 락이 걸려 있는 시간이 길면 동시성이 줄어들기에 잠그는 시간을 최소화 해야함
  - 락이 걸린 작업의 크기를 최소화
  - 작업 크기 = 락이 잠그고 있는 영역의 크기
  - 한 고객이 잔고 변경시 해당 고객의 계좌만 잠그는 것

### 락 대기

- 프로그램이 락을 기다리는 동안 아무일도 못한다면 락을 세밀하게 만들어도 아무 이득이 없음
- **스핀** :  락을 성공적으로 얻을 때 까지 락 획득을 반복 시도
  - 전력 소모가 커짐
- **등록** 후 **통지** : 락을 관리하는 쪽에 등록하고, 요청이 받아들여졌을 때 통지 받는 방법
  - 규모를 쉽게 키우기 어렵고, 인터넷 아키텍처에서는 직접적으로 지원되지 않는다
- 이더넷의 경우 여러 장치가 공유 자원에 동시 접근해서 충돌하는 경우 임의의 시간을 기다린 다음 재시도

### 교착상태

- 아래와 같은 상황을 교착상태라고 함
  - 프로그램1 - 락 A 획득
  - 프로그램2 - 락 B 획득
  - 프로그램1 - 락 B 필요
- 코드를 잘 짜는 것 말고는 피하는 방법이 없긴 함
  - 락을 해제하겠냐고 물어보는 메세지를 표기하기도 함



## 브라우저 자바스크립트

- 자바스크립트는 단일 스레드로 돌아가면서도 동시성이 문제가 됨

- 자바스크립트의 원래 목표는 더 빠르게 사용자 피드백을 제공하고 인터넷 트래픽을 줄이기 위함

  - ex)카드 번호를 입력 -> 서버에서 데이터가 숫자로만 되어 있는지 확인 -> 오류 반환을 브라우저 선에서 처리 가능

-  자스는 사용자 이벤트에 응답하는 짧은 프로그램을 실행하기 위해 만들어졌기 때문에 구현에 **이벤트 루프** 모델 사용

  - **이벤트 큐**에서 응답 실행 : 이벤트 도착을 기다림 -> 이벤트를 큐에서 꺼냄 -> 이벤트 코드를 실행 -> 이벤트 도착을 기다림 반복
  - 단일 스레드 프로그램이기 떄문에 이 작업을 중간에 인터럽트 할 수 없음 (이벤트 순서 조작 안됨)

  

- 자바스크립트 초기에는 비동기 통신을 언어 설계에 포함하지 않았음

  - DOM의 등장으로 기존 웹 페이지 전체를 바꾸는 대신 일부만 변경 가능
  - XHR(XML Http Request)의 등장으로 페이지 로드 모델에서 벗어나 백그라운드에서 브라우저와 서버가 통신할 수 있게 됨
  - 이런 변화로 인해 비동기 통신이 중요한 문제로 떠오름

## 비동기 함수와 프로미스

- **프로미스(promise)**를 추가해 문제를 처리하기 시작
  - 비동기 콜백 메커니즘을 언어 고유 기능으로 넣어서 라이브러리가 잘못된 비동기 연산을 구현하지 못하게 함
  - 자세한 내용은 [MDN web docs Promise](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise)에서 확인하자
