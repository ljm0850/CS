# 웹 브라우저

- 추상적인 컴퓨터를 이해하기 위한 가상 머신
- 인터프리터의 일종

## 마크업 언어

- **마크업** : 본문(텍스트)과 구분할 수 있는 마크를 추가할 수 있는 시스템
- 일부 문자에 특벌한 기능을 넣어 마크업
- IBM에서 GML (generalized Markup Language)를 만들고 이를 확장하여 SGML(standard GML)을 표준으로 채택
- SGML를 뿌리로 XML, HTML이 만들어짐 (SGML 표준을 준수하지는 않음)

## 균일 자원 위치 지정자(URL, Uniform Resource Locator)

- URL을 사용해 HTTP 프로토콜을 통해 서버에게 문서를 요청
- 서버는 문서를 브라우저에게 보내고, 브라우저는 문서를 표시하는 역할
- URL은 일정한 구조를 따르는 텍스트 문자열
  - https://github.com/ljm0850
  - scheme : https에 해당, 통신 매커니즘을 표시
    - Scheme 중에서는 file도 있어서 실행중인 컴퓨터의 파일을 가리킬 수 있음
  - host : GitHub.com 에 해당, 통신하려는 서버, 숫자로 된 인터넷 주소 일 수도 있지만, 일반적으로는 도메인 이름을 사용
  - Path : ljm0850 에 해당, 문서는 경로가 가리키는 위치에서 추출됨

## HTML 문서

- Hypertext : 웹 페이지 등 다른 대상에 대한 링크가 들어있는 텍스트
- `<tag></tag>`는  브라우저가 마크업 엘리먼트를 어떻게 해석할지를 결정
  - 태그에는 attribute가 포함 될 수 있음
    - ex) class

## DOM : 문서 객체 모델

- 웹 브라우저는 문서를 문서 객체 모델(DOM)에 따라 처리함
- HTML문서는 일종의 트리 구조
  - html 안에 head, body를 가진 구조, head에는 title ... 등

### DOM 처리

- 브라우저는 문서트리를 이용하여 dfs방식으로 트리를 해석

## CSS

- 초기 HTML 아이디어는 웹 페이지를 작성한 사람이 HTML로 페이지를 작성하면 브라우저가 웹 페이지를 표시해줄 방법을 스스로 알아내는 것
- 브라우저의 창 크기, 화면 해상도, 사용할 수 있는 색이나 글꼴 종류 등을 알 방법이 없었기에 이런 아이디어
- 마케터가 웹에 관여하며 시각적 효과가 중요해져 페이지가 표시되는 모습을 세밀하게 조정할 수 있도록 다양한 기능(주로 CSS 명세를 통해)이 추가됨
  - 이는 웹의 의도와 반대되는 일이었기에 웹이 지저분해지긴함
- 즉 CSS는 HTML에서 스타일 정보를 분리해서 HTML을 한 번만 작성해도 대상 장치에 따라 여러 스타일을 적용할 수 있게 만듬
- 이로인해 여러 HTML 원소 사이의 구분을 없애버리는 결과를 낳게 되긴 함 (h1, p 같은 태그의 의미가 없어짐..)  



## XML 등의 마크업 언어

- HTML은 웹 페이지라는 구체적인 응용을 위해 만들어짐
- XML은 더 일반적인 용도의 마크업 언어로 다양한 응용 분야 존재
- 대부분의 XML 태그는 미리 정해진 의미가 없음
- XML은 원하는 대로 태그에 의미 부여가 가능 => 자기만의 커스텀된 마크업 언어 정의 가능
  - 두개 이상의 커스텀된 마크업 언어에서 태그가 겹칠때 문제 발생
  - 이를 구분하기 위해 **이름 공간** 방법이 만들어짐(엘리멘트 태그 앞에 접두사를 붙이는 방법)
  - `<jaeminml:name>tomato</vml:name>` `<ljmml:name>tomato</rml:name>`
  - 여기서jaeminml과 ljmml은 각각 커스텀된 마크업 언어
- **DTD**(Document Type Definition, 문서 타입 정의)
  - XML 처럼 보이는 문서
  - 마크업 언어 문법에 맞는 엘리먼트가 어떻게 생겼는지를 정의
    - ex)특정 엘리멘트 안에는 필수 엘리멘트1이 있어야 하고, 엘리멘트1,2,3,4 만 허용이 된다



## 자바스크립트(javascript)

- 기존의 웹 페이지는 정적 페이지
  - 미리 어떻게 표시될지 정해진 텍스트를 그대로 표시
  - 표시중인 내용을 변경하려면 새로운 URL을 웹 서버에 요청해서 새 문서를 받아오는 방법 뿐
- ECMA에서 표준 관리
- 서버가 아니라 브라우저(클라이언트) 단에서 실행될 수 있는 실제 프로그렘을 웹 페이지에 포함 가능
- DOM을 변경하고 직접 웹 서버와 통신
- 자바스크립트와 서버의 상호작용은 비동기 자바스크립트와 XML, 즉 AJAX를 통해 이루어 졌었음



## jQuery

- DOM 함수에는 두가지 문제가 존재
  - DOM 함수 동작이 브라우저마다 다를수 있다.
  - DOM 함수를 사용하기 상당히 불편하다.
- 미국 SW 엔지니어 존 레식이 만든 라이브러리
- 브라우저 사이의 불일치를 매꿔주어 프로그래머가 직접 브라우저 간의 차이를 다룰 필요가 없음
- DOM 조작 인터페이스 제공

```html
<html>
  <head>
    <title>타이틀</title>
    <style>
      body{
        color: blue;
      }
      big {
        color: yellow;
        font-size: 200%
      }
    </style>
    <!--jQuery import-->
    <script>
      $(funtion(){
        $('big').css('background','green')
        })
    </script>
  </head>
</html>
```

- `$('big')`은 실렉터, 실렉터로 선택한 원소에 대해 수행할 액션 정의하는 코드



## SVG

- 크기 변경이 가능한 벡터 그래픽스(Scalable Vector Graphics)
- 그래픽과 텍스트를 만들 수 있도록 지원하지만, 다른 마크업 언어와 전혀 다른 언어
- 브라우저에 PDF를 욱여 넣은 것과 비슷하지만, SVG와 PDF는 호환성이 없음
- SVG로 무엇을 그릴지 지시하면 그대로 그림이 그려짐
  - Canvas는 canvas를 조작하는 프로그램을 작성해야 함

```html
<svg xmlns="http://www.w3.org/2000/svg" width="400" height="400">
  <circle id='c' r='10' cx ='200' cy='200' fill='red'/>
</svg>
```



## HTML5

- 기존 HTML에서 `<header>` `<footer>` `<section>` `<audio>` `<video>`과 같은 여러 시멘틱 엘리먼트가 추가됨
- **canvas**가 추가되었는데, SVG와 비슷한 기능을 제공하지만, 완전 다른 방식
  - SVG는 기존 DOM 함수를 사용해 조작
  - canvas는 canvas를 위해 만들어진 새로운 자바스크립트 함수를 통해 조작



## JSON

- 기존에는 AJAX를 사용했지만, 현재 JSON을 더 많이 사용
- JavaScript Object Notation
- JavaScript 객체를 JSON 형식으로 손쉽게 바꿀 수 있기에 주로 사용
- 분별없이 JSON데이터를 eval로 임포트시 공격자가 원하는 코드를 브라우저에서 실행하도록 허용이 가능
  -  이를 위해 안전하게 객체로 되돌리기 위해 **JSON.parse**라는 함수가 추가됨
