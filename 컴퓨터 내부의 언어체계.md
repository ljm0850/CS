# 컴퓨터 내부의 언어체계

- **비트(bit)**
  - bit는 binanry(2진법)와 digit(10진수)를 합친말
  - 2진법을 사용하여 기호를 담음

## 논리연산

- `true`/`false`
- 다른 비트들이 표현하는 내용으로 부터 새로운 비트를 만들어 내는 동작



### 불리언 대수

- 수학자 George Boole이 만든 **연산 규칙**의 집합
- **NOT** 
  - 논리적 반대
  - false인 비트에 NOT => true
  - true인 비트에 NOT => false 

- **AND**
  - 둘 이상의 비트에 작용
  - 모든 비트가 true => true
  - 하나 이상의 비트가 false => false
- **OR**
  - 둘 이상의 비트에 작용
  - 모든 비트가 false => false
  - 하나 이상의 비트가 true => true

- **XOR**
  - exclusive OR
  - 첫 번째 비트와 두 번째 비트가 다른 값인 경우에만 true



### 드모르간의 법칙

- a AND b == NOT(NOT a OR NOT b) 으로 대체 가능
- NOT을 잘 사용하면 AND연산을 OR 연산으로 대체 가능



## 정수를 비트로 표현

### 양의정수

- 비트는 0과 1 표현 가능 => 2진법
  - 정수를 2진수로 변환 
  - 비트의 개수 => 표현할 수 있는 값의 범위 (0~2^n-1)
- **가장 작은 유효 비트(least significant bit,LSB)**: 2진수에서 가장 오른쪽 비트
- **가장 큰 유효 비트(most significant bit,MSB)**: 2진수에서 가장 왼쪽 비트

- 리딩 제로(0850<->850 에서 8앞의 0과 같이 추가된 0)



### 2진수 덧셈

- 일반적인 이진법 덧셈과 같이 각 비트를 LSB에서 MSB 쪽으로 더하여 결과가 1보다 크면 1을 다음 자리로 올림
- `A+B` 는`A AND B`와 `A XOR B`연산을 통해 구할 수 있다.

| A    | B    | A AND B | A+B  | A XOR B |
| ---- | ---- | ------- | ---- | ------- |
| 0    | 0    | 0       | 00   | 0       |
| 0    | 1    | 0       | 01   | 1       |
| 1    | 0    | 0       | 01   | 1       |
| 1    | 1    | 1       | 10   | 0       |

#### 오버플로

- MSB에서 올림이 발생했다는 뜻
- 조건(상태) 코드 레지스터 중 오버플로 비트가 있어 MSB에서 발생한 올림 값을 저장하여 오버플로 발생을 확인

#### 언더플로

- MSB 위쪽에서 1을 빌려오는 경우
- 뺄셈(음수를 덧셈)하는 경우 사용



### 음수 표현

#### 부호와 크기(sign and magnitude) 표현법

- 가장 왼쪽 비트(MSB)를 부호에 사용하여 표기(MSB가 1이면 음수)
  - 이로 인해 4비트가 0~15가 아닌 -7~7을 표기

- 단점
  - 0을 표현하는 방법이 두 가지라서 비용이 낭비
  - XOR, AND를 통한 덧셈 계산이 불가
    - `0001 AND 1001 = 1010` (1+(-1)이 -2로 계산)

#### 1의 보수(one's complement)

- 양수의 모든 비트를 뒤집어 표기
- 단점
  - 0을 표현하는 방법이 두가지
  - MSB에서 올림이 발생한 경우 LSB에 올림을 전달하는 순환 올림(end-around carry)이 필요
    - `0010 AND 1110 연산에서 MSB에서 올림 발생 => 순환 올림하여 0001로 계산`(2와 -1의 AND 연산)
    - 순환 올림을 처리하기 위한 추가적인 하드웨어가 필요해짐

#### 2의 보수(two's complement)

- 현재 주로 사용

- +1에 값을 더했을때 0이 나오는 비트 패턴을 -1로 계산
  - `0001 AND 1111 = 0000`, 1111을 -1로 계산

- 4비트로 -8~7사이의 수 표현 가능



## 실수 표현

### 고정소수점 표현법(fixed-point)

- 2진 소수점의 위치를 임의로 지정해서 사용 하는 방법
- 4비트에서 2비트는 소수점 왼쪽을 표현, 나머지 2비트는 소수점 오른쪽을 표현 하는 방법
  - `00/01 = 1/4, 10/10 = 2+(1/2)`
- 디지털 신호 처리 장치(Digital Signal Processor)등 일부 컴퓨터에서 사용

- 쓸모 있는 범위의 실수값을 표현하기 위해 필요한 비트의 개수가 너무 많아 자주 사용하는 방식은 아님



### 부동소수점 표현법(floating-point)

- 과학적 표기법을 2진수에 적용
  - 가수(mantissa,소수점 왼쪽이 한 자리뿐인 소수)에 2^n의 지수를 도입하여 표기
  - `1.000 = 1*2^0, 1.011 = 1*2^3`
- 단점
  - 낭비가 많음
    - 0을 표현하는 방법이 4가지
    - 1.0, 2.0, ... 을 표현하는 방법이 2가지
  - 비트 패턴이 가능한 모든 수를 표현하지 못함
    - 지수가 커질수록 가수의 한 패턴과 다른 패턴 사이의 값 차이가 커짐
    - 0.5+0.5 = 1.0은 가능, 0.5+6.0 인 6.5를 표현하는 비트가 없어 계산 불가
    - 수치 해석(numerical) = 이러한 부정확한 계산을 추적,개선하는 분야

### IEEE 부동소수점 수 표준

- 미국 전자전기공학회(Institute of Electrical and Electronic Engineers)에서 정한 표준
- 여러 방법을 통해 정밀도(precision)를 높이기 위한 방법
  - 정규화(nomalization,가수를 조정해서 맨 앞에 0이 없게 만드는 것)
  - 가수의 맨 왼쪽 비트는 항상 1이므로 생략
- 기본 정밀도(single precision), 2배 정밀도(double precision)를 주로 사용
  - 기본 정밀도는 32비트사용,7비트 정밀도
    - 1개의 비트는 가수에 대한 부호
    - 8개의 비트는 지수 표현
    - 23개의 비트는 가수 표현
  - 2배 정밀도는 64비트 사용, 15비트 정밀도



### BCD(2진 코드화한 10진수)

- 비트 4개를 사용하여 10진수 1개를 표현하는 방식
  - 표현가능한 16개에서 10개만 사용
- 디스플레이,가속도 센서에서 가끔 사용



## 텍스트 표현

### 아스키코드

- American Standard Code for Information Interchange
- 8비트로 문자 표기
- 키보드에 있는 모든 기호와 장치를 제어하기 위한 제어 문자를 할당한 것
- https://ko.wikipedia.org/wiki/ASCII

### 다른 표준들

- 아스키 코드는 영어를 표현하는데 필요한 문자를 포함
- 다른 언어를 지원해주는 방식이 필요하여 ISO-646, ISO-8859 도입
  - 비트가 비싼 시절이라 각자 표준을 만들어 사용
- 이를 통합하여 유니코드가 탄생
  - 초기엔 16비트, 이후 21비트까지 확장

### 유니코드 변환

- 16비트 문자를 쓰기엔 낭비가 심하므로 인코딩하여 변환 하는 형식

- 문자 코드에 따라 각기 다른 인코딩을 사용하여 변환
- 주로 하위 호환성과 효율성 관계로 UTF-8이 주로 사용